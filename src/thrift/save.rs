// Autogenerated by Thrift Compiler (0.20.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box, clippy::wrong_self_convention)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ClassType(pub i32);

impl ClassType {
  pub const JOURNEYMAN: ClassType = ClassType(0);
  pub const FIGHTER: ClassType = ClassType(1);
  pub const PRIEST: ClassType = ClassType(2);
  pub const THIEF: ClassType = ClassType(3);
  pub const SPELLCASTER: ClassType = ClassType(4);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::JOURNEYMAN,
    Self::FIGHTER,
    Self::PRIEST,
    Self::THIEF,
    Self::SPELLCASTER,
  ];
}

impl TSerializable for ClassType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ClassType> {
    let enum_value = i_prot.read_i32()?;
    Ok(ClassType::from(enum_value))
  }
}

impl From<i32> for ClassType {
  fn from(i: i32) -> Self {
    match i {
      0 => ClassType::JOURNEYMAN,
      1 => ClassType::FIGHTER,
      2 => ClassType::PRIEST,
      3 => ClassType::THIEF,
      4 => ClassType::SPELLCASTER,
      _ => ClassType(i)
    }
  }
}

impl From<&i32> for ClassType {
  fn from(i: &i32) -> Self {
    ClassType::from(*i)
  }
}

impl From<ClassType> for i32 {
  fn from(e: ClassType) -> i32 {
    e.0
  }
}

impl From<&ClassType> for i32 {
  fn from(e: &ClassType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RaceType(pub i32);

impl RaceType {
  pub const HUMAN: RaceType = RaceType(0);
  pub const ELF: RaceType = RaceType(1);
  pub const DWARF: RaceType = RaceType(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::HUMAN,
    Self::ELF,
    Self::DWARF,
  ];
}

impl TSerializable for RaceType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RaceType> {
    let enum_value = i_prot.read_i32()?;
    Ok(RaceType::from(enum_value))
  }
}

impl From<i32> for RaceType {
  fn from(i: i32) -> Self {
    match i {
      0 => RaceType::HUMAN,
      1 => RaceType::ELF,
      2 => RaceType::DWARF,
      _ => RaceType(i)
    }
  }
}

impl From<&i32> for RaceType {
  fn from(i: &i32) -> Self {
    RaceType::from(*i)
  }
}

impl From<RaceType> for i32 {
  fn from(e: RaceType) -> i32 {
    e.0
  }
}

impl From<&RaceType> for i32 {
  fn from(e: &RaceType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Team(pub i32);

impl Team {
  pub const PLAYER: Team = Team(1);
  pub const ENEMY: Team = Team(2);
  pub const ANIMAL: Team = Team(3);
  pub const NPC: Team = Team(4);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::PLAYER,
    Self::ENEMY,
    Self::ANIMAL,
    Self::NPC,
  ];
}

impl TSerializable for Team {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Team> {
    let enum_value = i_prot.read_i32()?;
    Ok(Team::from(enum_value))
  }
}

impl From<i32> for Team {
  fn from(i: i32) -> Self {
    match i {
      1 => Team::PLAYER,
      2 => Team::ENEMY,
      3 => Team::ANIMAL,
      4 => Team::NPC,
      _ => Team(i)
    }
  }
}

impl From<&i32> for Team {
  fn from(i: &i32) -> Self {
    Team::from(*i)
  }
}

impl From<Team> for i32 {
  fn from(e: Team) -> i32 {
    e.0
  }
}

impl From<&Team> for i32 {
  fn from(e: &Team) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct IntelType(pub i32);

impl IntelType {
  pub const HUNTER: IntelType = IntelType(1);
  pub const GUILD_MASTER: IntelType = IntelType(2);
  pub const NPC: IntelType = IntelType(3);
  pub const MESSAGE_BEARER: IntelType = IntelType(4);
  pub const PLAYER: IntelType = IntelType(5);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::HUNTER,
    Self::GUILD_MASTER,
    Self::NPC,
    Self::MESSAGE_BEARER,
    Self::PLAYER,
  ];
}

impl TSerializable for IntelType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IntelType> {
    let enum_value = i_prot.read_i32()?;
    Ok(IntelType::from(enum_value))
  }
}

impl From<i32> for IntelType {
  fn from(i: i32) -> Self {
    match i {
      1 => IntelType::HUNTER,
      2 => IntelType::GUILD_MASTER,
      3 => IntelType::NPC,
      4 => IntelType::MESSAGE_BEARER,
      5 => IntelType::PLAYER,
      _ => IntelType(i)
    }
  }
}

impl From<&i32> for IntelType {
  fn from(i: &i32) -> Self {
    IntelType::from(*i)
  }
}

impl From<IntelType> for i32 {
  fn from(e: IntelType) -> i32 {
    e.0
  }
}

impl From<&IntelType> for i32 {
  fn from(e: &IntelType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ConditionType(pub i32);

impl ConditionType {
  pub const HEALTH: ConditionType = ConditionType(0);
  pub const ARMOR: ConditionType = ConditionType(1);
  pub const DEXTERITY: ConditionType = ConditionType(2);
  pub const STRENGTH: ConditionType = ConditionType(3);
  pub const POISON: ConditionType = ConditionType(4);
  pub const INTELIGENCE: ConditionType = ConditionType(5);
  pub const LUCK: ConditionType = ConditionType(6);
  pub const SPEED: ConditionType = ConditionType(7);
  pub const HIDDEN: ConditionType = ConditionType(8);
  pub const SNEAKING: ConditionType = ConditionType(9);
  pub const MANA: ConditionType = ConditionType(10);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::HEALTH,
    Self::ARMOR,
    Self::DEXTERITY,
    Self::STRENGTH,
    Self::POISON,
    Self::INTELIGENCE,
    Self::LUCK,
    Self::SPEED,
    Self::HIDDEN,
    Self::SNEAKING,
    Self::MANA,
  ];
}

impl TSerializable for ConditionType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ConditionType> {
    let enum_value = i_prot.read_i32()?;
    Ok(ConditionType::from(enum_value))
  }
}

impl From<i32> for ConditionType {
  fn from(i: i32) -> Self {
    match i {
      0 => ConditionType::HEALTH,
      1 => ConditionType::ARMOR,
      2 => ConditionType::DEXTERITY,
      3 => ConditionType::STRENGTH,
      4 => ConditionType::POISON,
      5 => ConditionType::INTELIGENCE,
      6 => ConditionType::LUCK,
      7 => ConditionType::SPEED,
      8 => ConditionType::HIDDEN,
      9 => ConditionType::SNEAKING,
      10 => ConditionType::MANA,
      _ => ConditionType(i)
    }
  }
}

impl From<&i32> for ConditionType {
  fn from(i: &i32) -> Self {
    ConditionType::from(*i)
  }
}

impl From<ConditionType> for i32 {
  fn from(e: ConditionType) -> i32 {
    e.0
  }
}

impl From<&ConditionType> for i32 {
  fn from(e: &ConditionType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ConditionSource(pub i32);

impl ConditionSource {
  pub const POTION: ConditionSource = ConditionSource(0);
  pub const PLAYER: ConditionSource = ConditionSource(1);
  pub const ITEM: ConditionSource = ConditionSource(2);
  pub const ENEMY: ConditionSource = ConditionSource(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::POTION,
    Self::PLAYER,
    Self::ITEM,
    Self::ENEMY,
  ];
}

impl TSerializable for ConditionSource {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ConditionSource> {
    let enum_value = i_prot.read_i32()?;
    Ok(ConditionSource::from(enum_value))
  }
}

impl From<i32> for ConditionSource {
  fn from(i: i32) -> Self {
    match i {
      0 => ConditionSource::POTION,
      1 => ConditionSource::PLAYER,
      2 => ConditionSource::ITEM,
      3 => ConditionSource::ENEMY,
      _ => ConditionSource(i)
    }
  }
}

impl From<&i32> for ConditionSource {
  fn from(i: &i32) -> Self {
    ConditionSource::from(*i)
  }
}

impl From<ConditionSource> for i32 {
  fn from(e: ConditionSource) -> i32 {
    e.0
  }
}

impl From<&ConditionSource> for i32 {
  fn from(e: &ConditionSource) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TrapKind(pub i32);

impl TrapKind {
  pub const SPARK1: TrapKind = TrapKind(1);
  pub const SPARK2: TrapKind = TrapKind(2);
  pub const SPARK3: TrapKind = TrapKind(3);
  pub const FLAME1: TrapKind = TrapKind(4);
  pub const FLAME2: TrapKind = TrapKind(5);
  pub const SLOWNESS: TrapKind = TrapKind(6);
  pub const WEAKNESS: TrapKind = TrapKind(7);
  pub const POISON: TrapKind = TrapKind(8);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SPARK1,
    Self::SPARK2,
    Self::SPARK3,
    Self::FLAME1,
    Self::FLAME2,
    Self::SLOWNESS,
    Self::WEAKNESS,
    Self::POISON,
  ];
}

impl TSerializable for TrapKind {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TrapKind> {
    let enum_value = i_prot.read_i32()?;
    Ok(TrapKind::from(enum_value))
  }
}

impl From<i32> for TrapKind {
  fn from(i: i32) -> Self {
    match i {
      1 => TrapKind::SPARK1,
      2 => TrapKind::SPARK2,
      3 => TrapKind::SPARK3,
      4 => TrapKind::FLAME1,
      5 => TrapKind::FLAME2,
      6 => TrapKind::SLOWNESS,
      7 => TrapKind::WEAKNESS,
      8 => TrapKind::POISON,
      _ => TrapKind(i)
    }
  }
}

impl From<&i32> for TrapKind {
  fn from(i: &i32) -> Self {
    TrapKind::from(*i)
  }
}

impl From<TrapKind> for i32 {
  fn from(e: TrapKind) -> i32 {
    e.0
  }
}

impl From<&TrapKind> for i32 {
  fn from(e: &TrapKind) -> i32 {
    e.0
  }
}

//
// Fog
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Fog {
  pub current_map: Option<i32>,
  pub fog_by_map: Option<BTreeMap<i32, Vec<bool>>>,
}

impl Fog {
  pub fn new<F1, F2>(current_map: F1, fog_by_map: F2) -> Fog where F1: Into<Option<i32>>, F2: Into<Option<BTreeMap<i32, Vec<bool>>>> {
    Fog {
      current_map: current_map.into(),
      fog_by_map: fog_by_map.into(),
    }
  }
}

impl TSerializable for Fog {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Fog> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<BTreeMap<i32, Vec<bool>>> = Some(BTreeMap::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<i32, Vec<bool>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_0 = i_prot.read_i32()?;
            let list_ident = i_prot.read_list_begin()?;
            let mut map_val_1: Vec<bool> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_2 = i_prot.read_bool()?;
              map_val_1.push(list_elem_2);
            }
            i_prot.read_list_end()?;
            val.insert(map_key_0, map_val_1);
          }
          i_prot.read_map_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Fog {
      current_map: f_1,
      fog_by_map: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Fog");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.current_map {
      o_prot.write_field_begin(&TFieldIdentifier::new("current_map", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.fog_by_map {
      o_prot.write_field_begin(&TFieldIdentifier::new("fog_by_map", TType::Map, 2))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::List, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_i32(*k)?;
        o_prot.write_list_begin(&TListIdentifier::new(TType::Bool, v.len() as i32))?;
        for e in v {
          o_prot.write_bool(*e)?;
        }
        o_prot.write_list_end()?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Actor
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Actor {
  pub state: Option<i32>,
  pub x: Option<OrderedFloat<f64>>,
  pub y: Option<OrderedFloat<f64>>,
  pub dead: Option<bool>,
}

impl Actor {
  pub fn new<F1, F2, F3, F4>(state: F1, x: F2, y: F3, dead: F4) -> Actor where F1: Into<Option<i32>>, F2: Into<Option<OrderedFloat<f64>>>, F3: Into<Option<OrderedFloat<f64>>>, F4: Into<Option<bool>> {
    Actor {
      state: state.into(),
      x: x.into(),
      y: y.into(),
      dead: dead.into(),
    }
  }
}

impl TSerializable for Actor {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Actor> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    let mut f_3: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    let mut f_4: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_2 = Some(val);
        },
        3 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Actor {
      state: f_1,
      x: f_2,
      y: f_3,
      dead: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Actor");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.state {
      o_prot.write_field_begin(&TFieldIdentifier::new("state", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.x {
      o_prot.write_field_begin(&TFieldIdentifier::new("x", TType::Double, 2))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.y {
      o_prot.write_field_begin(&TFieldIdentifier::new("y", TType::Double, 3))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.dead {
      o_prot.write_field_begin(&TFieldIdentifier::new("dead", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ButtonPicker
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ButtonPicker {
}

impl ButtonPicker {
  pub fn new() -> ButtonPicker {
    ButtonPicker {}
  }
}

impl TSerializable for ButtonPicker {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ButtonPicker> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ButtonPicker {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ButtonPicker");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ButtonEmpty
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ButtonEmpty {
}

impl ButtonEmpty {
  pub fn new() -> ButtonEmpty {
    ButtonEmpty {}
  }
}

impl TSerializable for ButtonEmpty {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ButtonEmpty> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ButtonEmpty {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ButtonEmpty");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ButtonInventory
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ButtonInventory {
}

impl ButtonInventory {
  pub fn new() -> ButtonInventory {
    ButtonInventory {}
  }
}

impl TSerializable for ButtonInventory {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ButtonInventory> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ButtonInventory {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ButtonInventory");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ButtonMelee
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ButtonMelee {
}

impl ButtonMelee {
  pub fn new() -> ButtonMelee {
    ButtonMelee {}
  }
}

impl TSerializable for ButtonMelee {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ButtonMelee> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ButtonMelee {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ButtonMelee");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ButtonPickUp
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ButtonPickUp {
}

impl ButtonPickUp {
  pub fn new() -> ButtonPickUp {
    ButtonPickUp {}
  }
}

impl TSerializable for ButtonPickUp {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ButtonPickUp> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ButtonPickUp {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ButtonPickUp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ButtonRanged
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ButtonRanged {
}

impl ButtonRanged {
  pub fn new() -> ButtonRanged {
    ButtonRanged {}
  }
}

impl TSerializable for ButtonRanged {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ButtonRanged> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ButtonRanged {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ButtonRanged");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ButtonStats
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ButtonStats {
}

impl ButtonStats {
  pub fn new() -> ButtonStats {
    ButtonStats {}
  }
}

impl TSerializable for ButtonStats {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ButtonStats> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ButtonStats {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ButtonStats");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ButtonItem
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ButtonItem {
  pub prop_id: Option<i32>,
  pub quantity: Option<i32>,
}

impl ButtonItem {
  pub fn new<F1, F2>(prop_id: F1, quantity: F2) -> ButtonItem where F1: Into<Option<i32>>, F2: Into<Option<i32>> {
    ButtonItem {
      prop_id: prop_id.into(),
      quantity: quantity.into(),
    }
  }
}

impl TSerializable for ButtonItem {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ButtonItem> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ButtonItem {
      prop_id: f_1,
      quantity: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ButtonItem");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.prop_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("prop_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.quantity {
      o_prot.write_field_begin(&TFieldIdentifier::new("quantity", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ButtonSneak
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ButtonSneak {
}

impl ButtonSneak {
  pub fn new() -> ButtonSneak {
    ButtonSneak {}
  }
}

impl TSerializable for ButtonSneak {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ButtonSneak> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ButtonSneak {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ButtonSneak");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ButtonHide
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ButtonHide {
}

impl ButtonHide {
  pub fn new() -> ButtonHide {
    ButtonHide {}
  }
}

impl TSerializable for ButtonHide {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ButtonHide> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ButtonHide {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ButtonHide");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ButtonSpellbook
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ButtonSpellbook {
}

impl ButtonSpellbook {
  pub fn new() -> ButtonSpellbook {
    ButtonSpellbook {}
  }
}

impl TSerializable for ButtonSpellbook {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ButtonSpellbook> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ButtonSpellbook {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ButtonSpellbook");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ButtonSpell
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ButtonSpell {
  pub spell_id: Option<i32>,
}

impl ButtonSpell {
  pub fn new<F1>(spell_id: F1) -> ButtonSpell where F1: Into<Option<i32>> {
    ButtonSpell {
      spell_id: spell_id.into(),
    }
  }
}

impl TSerializable for ButtonSpell {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ButtonSpell> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ButtonSpell {
      spell_id: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ButtonSpell");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.spell_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("spell_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Button
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Button {
  Picker(ButtonPicker),
  Empty(ButtonEmpty),
  Inventory(ButtonInventory),
  Melee(ButtonMelee),
  Pickup(ButtonPickUp),
  Ranged(ButtonRanged),
  Stats(ButtonStats),
  Item(ButtonItem),
  Sneak(ButtonSneak),
  Hide(ButtonHide),
  Spellbook(ButtonSpellbook),
  Spell(ButtonSpell),
}

impl TSerializable for Button {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Button> {
    let mut ret: Option<Button> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ButtonPicker::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(Button::Picker(val));
          }
          received_field_count += 1;
        },
        2 => {
          let val = ButtonEmpty::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(Button::Empty(val));
          }
          received_field_count += 1;
        },
        3 => {
          let val = ButtonInventory::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(Button::Inventory(val));
          }
          received_field_count += 1;
        },
        4 => {
          let val = ButtonMelee::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(Button::Melee(val));
          }
          received_field_count += 1;
        },
        5 => {
          let val = ButtonPickUp::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(Button::Pickup(val));
          }
          received_field_count += 1;
        },
        6 => {
          let val = ButtonRanged::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(Button::Ranged(val));
          }
          received_field_count += 1;
        },
        7 => {
          let val = ButtonStats::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(Button::Stats(val));
          }
          received_field_count += 1;
        },
        8 => {
          let val = ButtonItem::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(Button::Item(val));
          }
          received_field_count += 1;
        },
        9 => {
          let val = ButtonSneak::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(Button::Sneak(val));
          }
          received_field_count += 1;
        },
        10 => {
          let val = ButtonHide::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(Button::Hide(val));
          }
          received_field_count += 1;
        },
        11 => {
          let val = ButtonSpellbook::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(Button::Spellbook(val));
          }
          received_field_count += 1;
        },
        12 => {
          let val = ButtonSpell::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(Button::Spell(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote Button"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote Button"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Button");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      Button::Picker(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("picker", TType::Struct, 1))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      Button::Empty(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("empty", TType::Struct, 2))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      Button::Inventory(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("inventory", TType::Struct, 3))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      Button::Melee(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("melee", TType::Struct, 4))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      Button::Pickup(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("pickup", TType::Struct, 5))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      Button::Ranged(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("ranged", TType::Struct, 6))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      Button::Stats(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("stats", TType::Struct, 7))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      Button::Item(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("item", TType::Struct, 8))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      Button::Sneak(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("sneak", TType::Struct, 9))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      Button::Hide(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("hide", TType::Struct, 10))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      Button::Spellbook(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("spellbook", TType::Struct, 11))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      Button::Spell(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("spell", TType::Struct, 12))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Buttons
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Buttons {
  pub buttons: Option<Vec<Vec<Button>>>,
  pub tab: Option<i32>,
}

impl Buttons {
  pub fn new<F1, F2>(buttons: F1, tab: F2) -> Buttons where F1: Into<Option<Vec<Vec<Button>>>>, F2: Into<Option<i32>> {
    Buttons {
      buttons: buttons.into(),
      tab: tab.into(),
    }
  }
}

impl TSerializable for Buttons {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Buttons> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<Vec<Button>>> = Some(Vec::new());
    let mut f_2: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<Button>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_3: Vec<Button> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_4 = Button::read_from_in_protocol(i_prot)?;
              list_elem_3.push(list_elem_4);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_3);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Buttons {
      buttons: f_1,
      tab: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Buttons");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.buttons {
      o_prot.write_field_begin(&TFieldIdentifier::new("buttons", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::List, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, e.len() as i32))?;
        for e in e {
          e.write_to_out_protocol(o_prot)?;
        }
        o_prot.write_list_end()?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.tab {
      o_prot.write_field_begin(&TFieldIdentifier::new("tab", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Cast
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Cast {
  pub map_id: Option<i32>,
  pub quest_log: Option<BTreeSet<i32>>,
  pub actor_save_by_id: Option<BTreeMap<i32, Actor>>,
  pub vars: Option<Vec<i32>>,
}

impl Cast {
  pub fn new<F1, F2, F3, F4>(map_id: F1, quest_log: F2, actor_save_by_id: F3, vars: F4) -> Cast where F1: Into<Option<i32>>, F2: Into<Option<BTreeSet<i32>>>, F3: Into<Option<BTreeMap<i32, Actor>>>, F4: Into<Option<Vec<i32>>> {
    Cast {
      map_id: map_id.into(),
      quest_log: quest_log.into(),
      actor_save_by_id: actor_save_by_id.into(),
      vars: vars.into(),
    }
  }
}

impl TSerializable for Cast {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Cast> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<BTreeSet<i32>> = Some(BTreeSet::new());
    let mut f_3: Option<BTreeMap<i32, Actor>> = Some(BTreeMap::new());
    let mut f_4: Option<Vec<i32>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let set_ident = i_prot.read_set_begin()?;
          let mut val: BTreeSet<i32> = BTreeSet::new();
          for _ in 0..set_ident.size {
            let set_elem_5 = i_prot.read_i32()?;
            val.insert(set_elem_5);
          }
          i_prot.read_set_end()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<i32, Actor> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_6 = i_prot.read_i32()?;
            let map_val_7 = Actor::read_from_in_protocol(i_prot)?;
            val.insert(map_key_6, map_val_7);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_8 = i_prot.read_i32()?;
            val.push(list_elem_8);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Cast {
      map_id: f_1,
      quest_log: f_2,
      actor_save_by_id: f_3,
      vars: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Cast");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.map_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("map_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.quest_log {
      o_prot.write_field_begin(&TFieldIdentifier::new("quest_log", TType::Set, 2))?;
      o_prot.write_set_begin(&TSetIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_set_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.actor_save_by_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("actor_save_by_id", TType::Map, 3))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_i32(*k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.vars {
      o_prot.write_field_begin(&TFieldIdentifier::new("vars", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Stage
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Stage {
  pub map_id: Option<i32>,
  pub player: Option<Box<Body>>,
  pub inventory_by_id: Option<BTreeMap<i32, Vec<Box<Body>>>>,
  pub pet: Option<Box<Body>>,
  pub quest_pet: Option<Box<Body>>,
  pub summoned_pet: Option<Box<Body>>,
  pub bodies: Option<Vec<Box<Body>>>,
  pub traps: Option<Vec<Box<Trap>>>,
}

impl Stage {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8>(map_id: F1, player: F2, inventory_by_id: F3, pet: F4, quest_pet: F5, summoned_pet: F6, bodies: F7, traps: F8) -> Stage where F1: Into<Option<i32>>, F2: Into<Option<Box<Body>>>, F3: Into<Option<BTreeMap<i32, Vec<Box<Body>>>>>, F4: Into<Option<Box<Body>>>, F5: Into<Option<Box<Body>>>, F6: Into<Option<Box<Body>>>, F7: Into<Option<Vec<Box<Body>>>>, F8: Into<Option<Vec<Box<Trap>>>> {
    Stage {
      map_id: map_id.into(),
      player: player.into(),
      inventory_by_id: inventory_by_id.into(),
      pet: pet.into(),
      quest_pet: quest_pet.into(),
      summoned_pet: summoned_pet.into(),
      bodies: bodies.into(),
      traps: traps.into(),
    }
  }
}

impl TSerializable for Stage {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Stage> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<Box<Body>> = None;
    let mut f_3: Option<BTreeMap<i32, Vec<Box<Body>>>> = Some(BTreeMap::new());
    let mut f_4: Option<Box<Body>> = None;
    let mut f_5: Option<Box<Body>> = None;
    let mut f_6: Option<Box<Body>> = None;
    let mut f_7: Option<Vec<Box<Body>>> = Some(Vec::new());
    let mut f_8: Option<Vec<Box<Trap>>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Box::new(Body::read_from_in_protocol(i_prot)?);
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<i32, Vec<Box<Body>>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_9 = i_prot.read_i32()?;
            let list_ident = i_prot.read_list_begin()?;
            let mut map_val_10: Vec<Box<Body>> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_11 = Box::new(Body::read_from_in_protocol(i_prot)?);
              map_val_10.push(list_elem_11);
            }
            i_prot.read_list_end()?;
            val.insert(map_key_9, map_val_10);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = Box::new(Body::read_from_in_protocol(i_prot)?);
          f_4 = Some(val);
        },
        5 => {
          let val = Box::new(Body::read_from_in_protocol(i_prot)?);
          f_5 = Some(val);
        },
        6 => {
          let val = Box::new(Body::read_from_in_protocol(i_prot)?);
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Box<Body>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_12 = Box::new(Body::read_from_in_protocol(i_prot)?);
            val.push(list_elem_12);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        8 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Box<Trap>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_13 = Box::new(Trap::read_from_in_protocol(i_prot)?);
            val.push(list_elem_13);
          }
          i_prot.read_list_end()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Stage {
      map_id: f_1,
      player: f_2,
      inventory_by_id: f_3,
      pet: f_4,
      quest_pet: f_5,
      summoned_pet: f_6,
      bodies: f_7,
      traps: f_8,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Stage");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.map_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("map_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.player {
      o_prot.write_field_begin(&TFieldIdentifier::new("player", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.inventory_by_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("inventory_by_id", TType::Map, 3))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::List, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_i32(*k)?;
        o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, v.len() as i32))?;
        for e in v {
          e.write_to_out_protocol(o_prot)?;
        }
        o_prot.write_list_end()?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.pet {
      o_prot.write_field_begin(&TFieldIdentifier::new("pet", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.quest_pet {
      o_prot.write_field_begin(&TFieldIdentifier::new("quest_pet", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.summoned_pet {
      o_prot.write_field_begin(&TFieldIdentifier::new("summoned_pet", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bodies {
      o_prot.write_field_begin(&TFieldIdentifier::new("bodies", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.traps {
      o_prot.write_field_begin(&TFieldIdentifier::new("traps", TType::List, 8))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CastSpell
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CastSpell {
  pub spell_id: Option<i32>,
  pub delay: Option<OrderedFloat<f64>>,
}

impl CastSpell {
  pub fn new<F1, F2>(spell_id: F1, delay: F2) -> CastSpell where F1: Into<Option<i32>>, F2: Into<Option<OrderedFloat<f64>>> {
    CastSpell {
      spell_id: spell_id.into(),
      delay: delay.into(),
    }
  }
}

impl TSerializable for CastSpell {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CastSpell> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CastSpell {
      spell_id: f_1,
      delay: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CastSpell");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.spell_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("spell_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.delay {
      o_prot.write_field_begin(&TFieldIdentifier::new("delay", TType::Double, 2))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Body
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Body {
  pub klass: Option<ClassType>,
  pub health: Option<i32>,
  pub magic: Option<i32>,
  pub level: Option<i32>,
  pub race: Option<RaceType>,
  pub actor_id: Option<i32>,
  pub team: Option<Team>,
  pub x: Option<OrderedFloat<f64>>,
  pub y: Option<OrderedFloat<f64>>,
  pub gold: Option<i32>,
  pub prop_id: Option<i32>,
  pub exp: Option<i32>,
  pub portrait_id: Option<i32>,
  pub name: Option<String>,
  pub hostile_to: Option<Team>,
  pub base_str: Option<i32>,
  pub base_int: Option<i32>,
  pub base_dex: Option<i32>,
  pub base_wis: Option<i32>,
  pub base_vit: Option<i32>,
  pub base_luck: Option<i32>,
  pub intel_type: Option<IntelType>,
  pub quantity: Option<i32>,
  pub equiped: Option<bool>,
  pub male: Option<bool>,
  pub persist: Option<bool>,
  pub frozen: Option<bool>,
  pub is_pet: Option<bool>,
  pub from_spawner: Option<bool>,
  pub wanderer: Option<Box<Wanderer>>,
  pub conditions: Option<Vec<Box<Condition>>>,
  pub last_spell: Option<CastSpell>,
  pub prefer_melee: Option<bool>,
}

impl Body {
  pub fn new<F1, F2, F4, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22, F23, F24, F25, F27, F28, F29, F30, F31, F32, F33, F34, F35, F36>(klass: F1, health: F2, magic: F4, level: F6, race: F7, actor_id: F8, team: F9, x: F10, y: F11, gold: F12, prop_id: F13, exp: F14, portrait_id: F15, name: F16, hostile_to: F17, base_str: F18, base_int: F19, base_dex: F20, base_wis: F21, base_vit: F22, base_luck: F23, intel_type: F24, quantity: F25, equiped: F27, male: F28, persist: F29, frozen: F30, is_pet: F31, from_spawner: F32, wanderer: F33, conditions: F34, last_spell: F35, prefer_melee: F36) -> Body where F1: Into<Option<ClassType>>, F2: Into<Option<i32>>, F4: Into<Option<i32>>, F6: Into<Option<i32>>, F7: Into<Option<RaceType>>, F8: Into<Option<i32>>, F9: Into<Option<Team>>, F10: Into<Option<OrderedFloat<f64>>>, F11: Into<Option<OrderedFloat<f64>>>, F12: Into<Option<i32>>, F13: Into<Option<i32>>, F14: Into<Option<i32>>, F15: Into<Option<i32>>, F16: Into<Option<String>>, F17: Into<Option<Team>>, F18: Into<Option<i32>>, F19: Into<Option<i32>>, F20: Into<Option<i32>>, F21: Into<Option<i32>>, F22: Into<Option<i32>>, F23: Into<Option<i32>>, F24: Into<Option<IntelType>>, F25: Into<Option<i32>>, F27: Into<Option<bool>>, F28: Into<Option<bool>>, F29: Into<Option<bool>>, F30: Into<Option<bool>>, F31: Into<Option<bool>>, F32: Into<Option<bool>>, F33: Into<Option<Box<Wanderer>>>, F34: Into<Option<Vec<Box<Condition>>>>, F35: Into<Option<CastSpell>>, F36: Into<Option<bool>> {
    Body {
      klass: klass.into(),
      health: health.into(),
      magic: magic.into(),
      level: level.into(),
      race: race.into(),
      actor_id: actor_id.into(),
      team: team.into(),
      x: x.into(),
      y: y.into(),
      gold: gold.into(),
      prop_id: prop_id.into(),
      exp: exp.into(),
      portrait_id: portrait_id.into(),
      name: name.into(),
      hostile_to: hostile_to.into(),
      base_str: base_str.into(),
      base_int: base_int.into(),
      base_dex: base_dex.into(),
      base_wis: base_wis.into(),
      base_vit: base_vit.into(),
      base_luck: base_luck.into(),
      intel_type: intel_type.into(),
      quantity: quantity.into(),
      equiped: equiped.into(),
      male: male.into(),
      persist: persist.into(),
      frozen: frozen.into(),
      is_pet: is_pet.into(),
      from_spawner: from_spawner.into(),
      wanderer: wanderer.into(),
      conditions: conditions.into(),
      last_spell: last_spell.into(),
      prefer_melee: prefer_melee.into(),
    }
  }
}

impl TSerializable for Body {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Body> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ClassType> = None;
    let mut f_2: Option<i32> = Some(0);
    let mut f_4: Option<i32> = Some(0);
    let mut f_6: Option<i32> = Some(0);
    let mut f_7: Option<RaceType> = None;
    let mut f_8: Option<i32> = None;
    let mut f_9: Option<Team> = None;
    let mut f_10: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    let mut f_11: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    let mut f_12: Option<i32> = Some(0);
    let mut f_13: Option<i32> = Some(0);
    let mut f_14: Option<i32> = Some(0);
    let mut f_15: Option<i32> = None;
    let mut f_16: Option<String> = Some("".to_owned());
    let mut f_17: Option<Team> = None;
    let mut f_18: Option<i32> = Some(0);
    let mut f_19: Option<i32> = Some(0);
    let mut f_20: Option<i32> = Some(0);
    let mut f_21: Option<i32> = Some(0);
    let mut f_22: Option<i32> = Some(0);
    let mut f_23: Option<i32> = Some(0);
    let mut f_24: Option<IntelType> = None;
    let mut f_25: Option<i32> = Some(0);
    let mut f_27: Option<bool> = Some(false);
    let mut f_28: Option<bool> = Some(false);
    let mut f_29: Option<bool> = Some(false);
    let mut f_30: Option<bool> = Some(false);
    let mut f_31: Option<bool> = Some(false);
    let mut f_32: Option<bool> = Some(false);
    let mut f_33: Option<Box<Wanderer>> = None;
    let mut f_34: Option<Vec<Box<Condition>>> = Some(Vec::new());
    let mut f_35: Option<CastSpell> = None;
    let mut f_36: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ClassType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = RaceType::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i32()?;
          f_8 = Some(val);
        },
        9 => {
          let val = Team::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        10 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_10 = Some(val);
        },
        11 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_i32()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_i32()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_i32()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_i32()?;
          f_15 = Some(val);
        },
        16 => {
          let val = i_prot.read_string()?;
          f_16 = Some(val);
        },
        17 => {
          let val = Team::read_from_in_protocol(i_prot)?;
          f_17 = Some(val);
        },
        18 => {
          let val = i_prot.read_i32()?;
          f_18 = Some(val);
        },
        19 => {
          let val = i_prot.read_i32()?;
          f_19 = Some(val);
        },
        20 => {
          let val = i_prot.read_i32()?;
          f_20 = Some(val);
        },
        21 => {
          let val = i_prot.read_i32()?;
          f_21 = Some(val);
        },
        22 => {
          let val = i_prot.read_i32()?;
          f_22 = Some(val);
        },
        23 => {
          let val = i_prot.read_i32()?;
          f_23 = Some(val);
        },
        24 => {
          let val = IntelType::read_from_in_protocol(i_prot)?;
          f_24 = Some(val);
        },
        25 => {
          let val = i_prot.read_i32()?;
          f_25 = Some(val);
        },
        27 => {
          let val = i_prot.read_bool()?;
          f_27 = Some(val);
        },
        28 => {
          let val = i_prot.read_bool()?;
          f_28 = Some(val);
        },
        29 => {
          let val = i_prot.read_bool()?;
          f_29 = Some(val);
        },
        30 => {
          let val = i_prot.read_bool()?;
          f_30 = Some(val);
        },
        31 => {
          let val = i_prot.read_bool()?;
          f_31 = Some(val);
        },
        32 => {
          let val = i_prot.read_bool()?;
          f_32 = Some(val);
        },
        33 => {
          let val = Box::new(Wanderer::read_from_in_protocol(i_prot)?);
          f_33 = Some(val);
        },
        34 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Box<Condition>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_14 = Box::new(Condition::read_from_in_protocol(i_prot)?);
            val.push(list_elem_14);
          }
          i_prot.read_list_end()?;
          f_34 = Some(val);
        },
        35 => {
          let val = CastSpell::read_from_in_protocol(i_prot)?;
          f_35 = Some(val);
        },
        36 => {
          let val = i_prot.read_bool()?;
          f_36 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Body {
      klass: f_1,
      health: f_2,
      magic: f_4,
      level: f_6,
      race: f_7,
      actor_id: f_8,
      team: f_9,
      x: f_10,
      y: f_11,
      gold: f_12,
      prop_id: f_13,
      exp: f_14,
      portrait_id: f_15,
      name: f_16,
      hostile_to: f_17,
      base_str: f_18,
      base_int: f_19,
      base_dex: f_20,
      base_wis: f_21,
      base_vit: f_22,
      base_luck: f_23,
      intel_type: f_24,
      quantity: f_25,
      equiped: f_27,
      male: f_28,
      persist: f_29,
      frozen: f_30,
      is_pet: f_31,
      from_spawner: f_32,
      wanderer: f_33,
      conditions: f_34,
      last_spell: f_35,
      prefer_melee: f_36,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Body");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.klass {
      o_prot.write_field_begin(&TFieldIdentifier::new("klass", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.health {
      o_prot.write_field_begin(&TFieldIdentifier::new("health", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.magic {
      o_prot.write_field_begin(&TFieldIdentifier::new("magic", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.level {
      o_prot.write_field_begin(&TFieldIdentifier::new("level", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.race {
      o_prot.write_field_begin(&TFieldIdentifier::new("race", TType::I32, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.actor_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("actor_id", TType::I32, 8))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.team {
      o_prot.write_field_begin(&TFieldIdentifier::new("team", TType::I32, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.x {
      o_prot.write_field_begin(&TFieldIdentifier::new("x", TType::Double, 10))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.y {
      o_prot.write_field_begin(&TFieldIdentifier::new("y", TType::Double, 11))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.gold {
      o_prot.write_field_begin(&TFieldIdentifier::new("gold", TType::I32, 12))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.prop_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("prop_id", TType::I32, 13))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.exp {
      o_prot.write_field_begin(&TFieldIdentifier::new("exp", TType::I32, 14))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.portrait_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("portrait_id", TType::I32, 15))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 16))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.hostile_to {
      o_prot.write_field_begin(&TFieldIdentifier::new("hostile_to", TType::I32, 17))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.base_str {
      o_prot.write_field_begin(&TFieldIdentifier::new("base_str", TType::I32, 18))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.base_int {
      o_prot.write_field_begin(&TFieldIdentifier::new("base_int", TType::I32, 19))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.base_dex {
      o_prot.write_field_begin(&TFieldIdentifier::new("base_dex", TType::I32, 20))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.base_wis {
      o_prot.write_field_begin(&TFieldIdentifier::new("base_wis", TType::I32, 21))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.base_vit {
      o_prot.write_field_begin(&TFieldIdentifier::new("base_vit", TType::I32, 22))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.base_luck {
      o_prot.write_field_begin(&TFieldIdentifier::new("base_luck", TType::I32, 23))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.intel_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("intel_type", TType::I32, 24))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.quantity {
      o_prot.write_field_begin(&TFieldIdentifier::new("quantity", TType::I32, 25))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.equiped {
      o_prot.write_field_begin(&TFieldIdentifier::new("equiped", TType::Bool, 27))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.male {
      o_prot.write_field_begin(&TFieldIdentifier::new("male", TType::Bool, 28))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.persist {
      o_prot.write_field_begin(&TFieldIdentifier::new("persist", TType::Bool, 29))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.frozen {
      o_prot.write_field_begin(&TFieldIdentifier::new("frozen", TType::Bool, 30))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_pet {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_pet", TType::Bool, 31))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.from_spawner {
      o_prot.write_field_begin(&TFieldIdentifier::new("from_spawner", TType::Bool, 32))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.wanderer {
      o_prot.write_field_begin(&TFieldIdentifier::new("wanderer", TType::Struct, 33))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.conditions {
      o_prot.write_field_begin(&TFieldIdentifier::new("conditions", TType::List, 34))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.last_spell {
      o_prot.write_field_begin(&TFieldIdentifier::new("last_spell", TType::Struct, 35))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.prefer_melee {
      o_prot.write_field_begin(&TFieldIdentifier::new("prefer_melee", TType::Bool, 36))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Wanderer
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Wanderer {
  pub x_min: Option<OrderedFloat<f64>>,
  pub y_min: Option<OrderedFloat<f64>>,
  pub x_max: Option<OrderedFloat<f64>>,
  pub y_max: Option<OrderedFloat<f64>>,
  pub rest_time: Option<OrderedFloat<f64>>,
}

impl Wanderer {
  pub fn new<F1, F2, F3, F4, F5>(x_min: F1, y_min: F2, x_max: F3, y_max: F4, rest_time: F5) -> Wanderer where F1: Into<Option<OrderedFloat<f64>>>, F2: Into<Option<OrderedFloat<f64>>>, F3: Into<Option<OrderedFloat<f64>>>, F4: Into<Option<OrderedFloat<f64>>>, F5: Into<Option<OrderedFloat<f64>>> {
    Wanderer {
      x_min: x_min.into(),
      y_min: y_min.into(),
      x_max: x_max.into(),
      y_max: y_max.into(),
      rest_time: rest_time.into(),
    }
  }
}

impl TSerializable for Wanderer {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Wanderer> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    let mut f_2: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    let mut f_3: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    let mut f_4: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    let mut f_5: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_1 = Some(val);
        },
        2 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_2 = Some(val);
        },
        3 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_3 = Some(val);
        },
        4 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_4 = Some(val);
        },
        5 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Wanderer {
      x_min: f_1,
      y_min: f_2,
      x_max: f_3,
      y_max: f_4,
      rest_time: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Wanderer");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.x_min {
      o_prot.write_field_begin(&TFieldIdentifier::new("x_min", TType::Double, 1))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.y_min {
      o_prot.write_field_begin(&TFieldIdentifier::new("y_min", TType::Double, 2))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.x_max {
      o_prot.write_field_begin(&TFieldIdentifier::new("x_max", TType::Double, 3))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.y_max {
      o_prot.write_field_begin(&TFieldIdentifier::new("y_max", TType::Double, 4))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.rest_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("rest_time", TType::Double, 5))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Condition
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Condition {
  pub kind: Option<ConditionType>,
  pub source: Option<ConditionSource>,
  pub course: Option<Box<Course>>,
  pub magnitude: Option<i32>,
}

impl Condition {
  pub fn new<F1, F2, F3, F4>(kind: F1, source: F2, course: F3, magnitude: F4) -> Condition where F1: Into<Option<ConditionType>>, F2: Into<Option<ConditionSource>>, F3: Into<Option<Box<Course>>>, F4: Into<Option<i32>> {
    Condition {
      kind: kind.into(),
      source: source.into(),
      course: course.into(),
      magnitude: magnitude.into(),
    }
  }
}

impl TSerializable for Condition {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Condition> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ConditionType> = None;
    let mut f_2: Option<ConditionSource> = None;
    let mut f_3: Option<Box<Course>> = None;
    let mut f_4: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ConditionType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = ConditionSource::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Box::new(Course::read_from_in_protocol(i_prot)?);
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Condition {
      kind: f_1,
      source: f_2,
      course: f_3,
      magnitude: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Condition");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.kind {
      o_prot.write_field_begin(&TFieldIdentifier::new("kind", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.source {
      o_prot.write_field_begin(&TFieldIdentifier::new("source", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.course {
      o_prot.write_field_begin(&TFieldIdentifier::new("course", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.magnitude {
      o_prot.write_field_begin(&TFieldIdentifier::new("magnitude", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TimedCourse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TimedCourse {
  pub duration: Option<OrderedFloat<f64>>,
}

impl TimedCourse {
  pub fn new<F1>(duration: F1) -> TimedCourse where F1: Into<Option<OrderedFloat<f64>>> {
    TimedCourse {
      duration: duration.into(),
    }
  }
}

impl TSerializable for TimedCourse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TimedCourse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TimedCourse {
      duration: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TimedCourse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.duration {
      o_prot.write_field_begin(&TFieldIdentifier::new("duration", TType::Double, 1))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PeriodicCourse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PeriodicCourse {
  pub period: Option<OrderedFloat<f64>>,
  pub ms_until_update: Option<OrderedFloat<f64>>,
}

impl PeriodicCourse {
  pub fn new<F1, F2>(period: F1, ms_until_update: F2) -> PeriodicCourse where F1: Into<Option<OrderedFloat<f64>>>, F2: Into<Option<OrderedFloat<f64>>> {
    PeriodicCourse {
      period: period.into(),
      ms_until_update: ms_until_update.into(),
    }
  }
}

impl TSerializable for PeriodicCourse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PeriodicCourse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    let mut f_2: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_1 = Some(val);
        },
        2 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = PeriodicCourse {
      period: f_1,
      ms_until_update: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PeriodicCourse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.period {
      o_prot.write_field_begin(&TFieldIdentifier::new("period", TType::Double, 1))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ms_until_update {
      o_prot.write_field_begin(&TFieldIdentifier::new("ms_until_update", TType::Double, 2))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PeriodicTimedCourse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PeriodicTimedCourse {
  pub timed: Option<TimedCourse>,
  pub periodic: Option<PeriodicCourse>,
}

impl PeriodicTimedCourse {
  pub fn new<F1, F2>(timed: F1, periodic: F2) -> PeriodicTimedCourse where F1: Into<Option<TimedCourse>>, F2: Into<Option<PeriodicCourse>> {
    PeriodicTimedCourse {
      timed: timed.into(),
      periodic: periodic.into(),
    }
  }
}

impl TSerializable for PeriodicTimedCourse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PeriodicTimedCourse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TimedCourse> = None;
    let mut f_2: Option<PeriodicCourse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TimedCourse::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = PeriodicCourse::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = PeriodicTimedCourse {
      timed: f_1,
      periodic: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PeriodicTimedCourse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.timed {
      o_prot.write_field_begin(&TFieldIdentifier::new("timed", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.periodic {
      o_prot.write_field_begin(&TFieldIdentifier::new("periodic", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MovementCanceledCourse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct MovementCanceledCourse {
}

impl MovementCanceledCourse {
  pub fn new() -> MovementCanceledCourse {
    MovementCanceledCourse {}
  }
}

impl TSerializable for MovementCanceledCourse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MovementCanceledCourse> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MovementCanceledCourse {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MovementCanceledCourse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RandomCourse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RandomCourse {
  pub periodic: Option<PeriodicCourse>,
  pub chance: Option<i32>,
}

impl RandomCourse {
  pub fn new<F1, F2>(periodic: F1, chance: F2) -> RandomCourse where F1: Into<Option<PeriodicCourse>>, F2: Into<Option<i32>> {
    RandomCourse {
      periodic: periodic.into(),
      chance: chance.into(),
    }
  }
}

impl TSerializable for RandomCourse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RandomCourse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<PeriodicCourse> = None;
    let mut f_2: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = PeriodicCourse::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RandomCourse {
      periodic: f_1,
      chance: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RandomCourse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.periodic {
      o_prot.write_field_begin(&TFieldIdentifier::new("periodic", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.chance {
      o_prot.write_field_begin(&TFieldIdentifier::new("chance", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// EquipedCourse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct EquipedCourse {
}

impl EquipedCourse {
  pub fn new() -> EquipedCourse {
    EquipedCourse {}
  }
}

impl TSerializable for EquipedCourse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<EquipedCourse> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = EquipedCourse {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("EquipedCourse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// EquipedPeriodicCourse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct EquipedPeriodicCourse {
}

impl EquipedPeriodicCourse {
  pub fn new() -> EquipedPeriodicCourse {
    EquipedPeriodicCourse {}
  }
}

impl TSerializable for EquipedPeriodicCourse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<EquipedPeriodicCourse> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = EquipedPeriodicCourse {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("EquipedPeriodicCourse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Course
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Course {
  Timed(TimedCourse),
  Periodic(PeriodicCourse),
  PeriodicTimed(PeriodicTimedCourse),
  MovementCanceled(MovementCanceledCourse),
  Random(RandomCourse),
  Equiped(EquipedCourse),
  EquipedPeriodic(EquipedPeriodicCourse),
}

impl TSerializable for Course {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Course> {
    let mut ret: Option<Course> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TimedCourse::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(Course::Timed(val));
          }
          received_field_count += 1;
        },
        2 => {
          let val = PeriodicCourse::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(Course::Periodic(val));
          }
          received_field_count += 1;
        },
        3 => {
          let val = PeriodicTimedCourse::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(Course::PeriodicTimed(val));
          }
          received_field_count += 1;
        },
        4 => {
          let val = MovementCanceledCourse::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(Course::MovementCanceled(val));
          }
          received_field_count += 1;
        },
        5 => {
          let val = RandomCourse::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(Course::Random(val));
          }
          received_field_count += 1;
        },
        6 => {
          let val = EquipedCourse::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(Course::Equiped(val));
          }
          received_field_count += 1;
        },
        7 => {
          let val = EquipedPeriodicCourse::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(Course::EquipedPeriodic(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote Course"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote Course"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Course");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      Course::Timed(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("timed", TType::Struct, 1))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      Course::Periodic(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("periodic", TType::Struct, 2))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      Course::PeriodicTimed(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("periodic_timed", TType::Struct, 3))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      Course::MovementCanceled(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("movement_canceled", TType::Struct, 4))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      Course::Random(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("random", TType::Struct, 5))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      Course::Equiped(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("equiped", TType::Struct, 6))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      Course::EquipedPeriodic(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("equiped_periodic", TType::Struct, 7))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AldonGame
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AldonGame {
  pub stage: Option<Stage>,
  pub cast: Option<Cast>,
  pub fog: Option<Fog>,
  pub buttons: Option<Buttons>,
}

impl AldonGame {
  pub fn new<F1, F2, F3, F4>(stage: F1, cast: F2, fog: F3, buttons: F4) -> AldonGame where F1: Into<Option<Stage>>, F2: Into<Option<Cast>>, F3: Into<Option<Fog>>, F4: Into<Option<Buttons>> {
    AldonGame {
      stage: stage.into(),
      cast: cast.into(),
      fog: fog.into(),
      buttons: buttons.into(),
    }
  }
}

impl TSerializable for AldonGame {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AldonGame> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Stage> = None;
    let mut f_2: Option<Cast> = None;
    let mut f_3: Option<Fog> = None;
    let mut f_4: Option<Buttons> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Stage::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Cast::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Fog::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = Buttons::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AldonGame {
      stage: f_1,
      cast: f_2,
      fog: f_3,
      buttons: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AldonGame");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.stage {
      o_prot.write_field_begin(&TFieldIdentifier::new("stage", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cast {
      o_prot.write_field_begin(&TFieldIdentifier::new("cast", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.fog {
      o_prot.write_field_begin(&TFieldIdentifier::new("fog", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.buttons {
      o_prot.write_field_begin(&TFieldIdentifier::new("buttons", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Trap
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Trap {
  pub x: Option<OrderedFloat<f64>>,
  pub y: Option<OrderedFloat<f64>>,
  pub kind: Option<TrapKind>,
}

impl Trap {
  pub fn new<F1, F2, F3>(x: F1, y: F2, kind: F3) -> Trap where F1: Into<Option<OrderedFloat<f64>>>, F2: Into<Option<OrderedFloat<f64>>>, F3: Into<Option<TrapKind>> {
    Trap {
      x: x.into(),
      y: y.into(),
      kind: kind.into(),
    }
  }
}

impl TSerializable for Trap {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Trap> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    let mut f_2: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    let mut f_3: Option<TrapKind> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_1 = Some(val);
        },
        2 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_2 = Some(val);
        },
        3 => {
          let val = TrapKind::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Trap {
      x: f_1,
      y: f_2,
      kind: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Trap");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.x {
      o_prot.write_field_begin(&TFieldIdentifier::new("x", TType::Double, 1))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.y {
      o_prot.write_field_begin(&TFieldIdentifier::new("y", TType::Double, 2))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.kind {
      o_prot.write_field_begin(&TFieldIdentifier::new("kind", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

